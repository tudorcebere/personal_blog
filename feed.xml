<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
  <generator uri="http://jekyllrb.com" version="4.0.1">Jekyll</generator>
  
  
  <link href="https://tudorcebere.github.io/personal_blog/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://tudorcebere.github.io/personal_blog/" rel="alternate" type="text/html" hreflang="en" />
  <updated>2020-07-08T17:23:24+00:00</updated>
  <id>https://tudorcebere.github.io/personal_blog//</id>

  
    <title type="html">Engineering Notes</title>
  

  
    <subtitle>Notes on stuff I learn.</subtitle>
  

  
    <author>
        <name>Tudor Cebere</name>
      
      
    </author>
  

  
  
    <entry>
      
      <title type="html">Python typing features</title>
      
      
      <link href="https://tudorcebere.github.io/personal_blog/2020/04/24/Python-typing-features/" rel="alternate" type="text/html" title="Python typing features" />
      
      <published>2020-04-24T06:10:56+00:00</published>
      <updated>2020-04-24T06:10:56+00:00</updated>
      <id>https://tudorcebere.github.io/personal_blog/2020/04/24/Python%20typing%20features</id>
      <content type="html" xml:base="https://tudorcebere.github.io/personal_blog/2020/04/24/Python-typing-features/">&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/whatsnew/3.8.html#typing&quot;&gt;Recent&lt;/a&gt; improvements in the typing module provided python amazing mechanisms for building healthier codebases.&lt;/p&gt;

&lt;p&gt;We will take a look at the following features:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;annotations in Python&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.ForwardRef&quot;&gt;ForwardRef&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#generics&quot;&gt;generics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.final&quot;&gt;@final&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;Annotations in Python&lt;/h2&gt;

&lt;p&gt;Annotations are a documentation or static typechecking tool that provide the expected value of an object. Thus, it will not raise errors or provide runtime warnings
at all. Still, annotations are making the code more readable and specific behaviors can be forced regarding typechecking. Lets explore the benefits of type annotations:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At a glance, when you are reading about &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt; for the first time, you cannot be sure of the types of the arguments at all, nor about the return type. If there are no docstrings
or documentation available, we need to grind through the code to understand the possible behaviors of the function.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By using annotations on the arguments and on the the return types, we can understand the expected behavior and the actual way to use &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt;. On a more detailed level, we can look at
the func object to see how annotations are stored. Upon running &lt;code class=&quot;highlighter-rouge&quot;&gt;dir&lt;/code&gt; on the &lt;code class=&quot;highlighter-rouge&quot;&gt;func&lt;/code&gt; object, we observe that we have the attribute &lt;code class=&quot;highlighter-rouge&quot;&gt;__annotations__&lt;/code&gt;. This is a dictionary with the keys
the kwargs of the function and the values the annotation value.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__annotations__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# {&quot;name&quot;: &amp;lt;class 'str'&amp;gt;, &quot;grades&quot;: &amp;lt;class 'list'&amp;gt;, &quot;return&quot;: &amp;lt;class 'dict'&amp;gt;}.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As we can see, we still can’t understand that much of the code, as the kwarg &lt;code class=&quot;highlighter-rouge&quot;&gt;grades&lt;/code&gt; expects a list, but we don’t know the actual typing of the elements in it. We should dig deeper to provide
support for generic subscripted typing.&lt;/p&gt;

&lt;h2&gt;Generics&lt;/h2&gt;

&lt;p&gt;Generics are abstract data types that describe a subclass of types. We will walk through the most common generics by explaining the following snippet:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dict&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;student_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]],&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]],&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;grade_modifiers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Lets analyse each kwarg to explain the documentation provided by the typing annotation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;student_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Mapping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;student_info&lt;/code&gt; kwarg expects a tuple with three elements, a string, a string and dict-like object that maps strings to ints. Lets take a deeper look.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Tuple&quot;&gt;Tuple&lt;/a&gt; describes that the type should be a &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt; that containts on each position instances of the subscripted types.&lt;/p&gt;

&lt;p&gt;Here he observe that the kwarg &lt;code class=&quot;highlighter-rouge&quot;&gt;student&lt;/code&gt; expects a tuple with three elements, a string, a string and a &lt;code class=&quot;highlighter-rouge&quot;&gt;Mapping&lt;/code&gt; generic type that we will talk through soon. The &lt;code class=&quot;highlighter-rouge&quot;&gt;Tuple&lt;/code&gt; generic is actually a gem, due to the actual immutability of tuples.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Mapping&quot;&gt;Mapping&lt;/a&gt; generic is the right way of describing key-value data structures like: &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ChainMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TypedValue&lt;/code&gt; or any custom key-value data structure, this one describers a mapping from &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; objects
to &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; objects.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Optional&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;grades&lt;/code&gt; expects either None or a list that contains either ints or floats.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Optional&quot;&gt;Optional&lt;/a&gt; describes that the type can be the subscripted type or &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;. By using the &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; generic on the &lt;code class=&quot;highlighter-rouge&quot;&gt;grades&lt;/code&gt; kwarg we mark the optional existence of an actual list.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional[Type]&lt;/code&gt; is equivalent with &lt;code class=&quot;highlighter-rouge&quot;&gt;Union[Type, None]&lt;/code&gt;. One might say that it should be &lt;code class=&quot;highlighter-rouge&quot;&gt;Union[Type, NoneType]&lt;/code&gt;, but as PEP 484 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484/#using-none&quot;&gt;states&lt;/a&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;NoneType&lt;/code&gt; are equivalent when type hinting. On a personal note, I don’t like this.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.List&quot;&gt;List&lt;/a&gt; describes that the type should be a &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt; that contains elements that are instaces of the subscripted type. In the above example, we observe that the list &lt;code class=&quot;highlighter-rouge&quot;&gt;grades&lt;/code&gt;, if it exists due to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Optional&lt;/code&gt; generic, should contain a Union type only, which we will cover next.&lt;/p&gt;

&lt;p&gt;We will see why we favor the usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Union&quot;&gt;Union&lt;/a&gt; describes that the  elements of the optional list of the kwarg &lt;code class=&quot;highlighter-rouge&quot;&gt;grades&lt;/code&gt; can be either &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;. Union types represent a common artificial parent of the subscripted types that can be used to represent all of them to a static typechecking tool.&lt;/p&gt;

&lt;p&gt;As a side note, there is no interpreter speedup on using Union types, as Python remains a dynamic language, compared to usage of union types in static languages like C.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;grade_modifiers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Iterable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Callable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]):&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;grade_modifiers&lt;/code&gt; kwarg expects a list-like structure that contains function-like objects that expect an int parameter and returns an int object.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Iterable&quot;&gt;Iterable&lt;/a&gt; generics are the way to describe an iterable type like: &lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, or any custom made type that is iterable, making in generic and permissive. The items generated by the iterator must be an instance of the
subscripted type of the generic. In the above example, the kwarg &lt;code class=&quot;highlighter-rouge&quot;&gt;grade_modifiers&lt;/code&gt; is an iterable object.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Callable&quot;&gt;Callable&lt;/a&gt; generic is an abstraction over any object that can be called on which we can enforce further typing, for example, &lt;code class=&quot;highlighter-rouge&quot;&gt;my_func = lambda x: x + 1&lt;/code&gt; has no possibility of further type hinting, but &lt;code class=&quot;highlighter-rouge&quot;&gt;my_func: Callable[int, int] = lambda x: x + 1&lt;/code&gt; gives the reader a type hint on the further usage of the lambda function.
Any callable object (functions, methods, lambda function, callable objects) are an instance of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt; generic.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Dict&quot;&gt;Dict&lt;/a&gt; describes that the return type of our function should be a &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt; with the keys of type &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; and value of type &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;.
This is not overall not recommended to use due to the lack of genericity, the corect way to represent such data structures is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Mapping&lt;/code&gt;, as this coveres generic key-value structures, one of the most interesting such objects being &lt;code class=&quot;highlighter-rouge&quot;&gt;TypedDict&lt;/code&gt;.&lt;/p&gt;

&lt;h2&gt;ForwardRef and future annotations&lt;/h2&gt;

&lt;p&gt;One of the common downfalls when using explicit type hinting is that it requires to actually have the type available when annotating. This generates boilerplate code that is not useful and can generate the
infamous circular dependecy error.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module.db1&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db1&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module.db2&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db2&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module.db3&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db3&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;db1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As of python3.8, if you are using the &lt;code class=&quot;highlighter-rouge&quot;&gt;annotations&lt;/code&gt; from the &lt;code class=&quot;highlighter-rouge&quot;&gt;__future__&lt;/code&gt; package, types can be stored as qualified string paths and will be resolved at runtime/when the typechecking tools needs it. This actually provided
an amazing speedup in the &lt;code class=&quot;highlighter-rouge&quot;&gt;typing&lt;/code&gt; package.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;__future__&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;annotations&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;module.db1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;module.db2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__annotations__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# {'name': &amp;lt;class 'str'&amp;gt;, 'grades': &amp;lt;class 'list'&amp;gt;, 'database': typing.Union['module.database1', 'module.database2']}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;If you are not using the annotations package, the interpreter creates &lt;code class=&quot;highlighter-rouge&quot;&gt;ForwardRef&lt;/code&gt; objects, as types are not stored as strings.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;module&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grades&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;module.db1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;module.db2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__annotations__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# {'name': &amp;lt;class 'str'&amp;gt;, 'grades': &amp;lt;class 'list'&amp;gt;, 'database': typing.Union[ForwardRef('module.database1'), ForwardRef('module.database2')]}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2&gt;Final and @final&lt;/h2&gt;
&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Final&lt;/code&gt; type and the &lt;code class=&quot;highlighter-rouge&quot;&gt;@final&lt;/code&gt; decorator are useful when:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a class shouldn’t be inherited.&lt;/li&gt;
  &lt;li&gt;a method shouldn’t be overriden.&lt;/li&gt;
  &lt;li&gt;a variable shouldn’t be reassigned.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Final&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;final&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# don't reassign me
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;PI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Final&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.14&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;#don't override me
&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;final&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PI&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NotImplemented&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# don't inherit me anymore
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;final&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Implementation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Breaking these constraints will result in raising an error. One interesting fact is the the &lt;code class=&quot;highlighter-rouge&quot;&gt;Final&lt;/code&gt; is actually a generic one, being able to be subscripted. Why would this be useful? To keep a reference to a container object, like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Final&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dict&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;grades_dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Final&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;dict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;In this post, we’ve observed how to improve a python codebase by providing better documentation and type hinting, enabling static type checking for IDEs. In further posts we will talk about building restrictions based on annotations.&lt;/p&gt;</content>

      
      
      
      
      

      
        <author>
            <name>Tudor Cebere</name>
          
          
        </author>
      

      
        <category term="python" />
      
        <category term="typing" />
      

      

      
        <summary type="html">Recent improvements in the typing module provided python amazing mechanisms for building healthier codebases. We will take a look at the following features: annotations in Python ForwardRef generics @final Annotations in Python Annotations are a documentation or static typechecking tool that provide the expected value of an object. Thus, it will not raise errors or provide runtime warnings at all. Still, annotations are making the code more readable and specific behaviors can be forced regarding typechecking. Lets explore the benefits of type annotations: def func(name, grades): ... At a glance, when you are reading about func for the first time, you cannot be sure of the types of the arguments at all, nor about the return type. If there are no docstrings or documentation available, we need to grind through the code to understand the possible behaviors of the function. def func(name: str, grades: list) -&amp;gt; dict: ... By using annotations on the arguments and on the the return types, we can understand the expected behavior and the actual way to use func. On a more detailed level, we can look at the func object to see how annotations are stored. Upon running dir on the func object, we observe that we have the attribute __annotations__. This is a dictionary with the keys the kwargs of the function and the values the annotation value. print(func.__annotations__) # {&quot;name&quot;: &amp;lt;class 'str'&amp;gt;, &quot;grades&quot;: &amp;lt;class 'list'&amp;gt;, &quot;return&quot;: &amp;lt;class 'dict'&amp;gt;}. As we can see, we still can’t understand that much of the code, as the kwarg grades expects a list, but we don’t know the actual typing of the elements in it. We should dig deeper to provide support for generic subscripted typing. Generics Generics are abstract data types that describe a subclass of types. We will walk through the most common generics by explaining the following snippet: from typing import Tuple, Mapping, Optional, List, Union, Iterable, Callable, Dict def func(student_info: Tuple[str, str, Mapping[str, int]], grades: Optional[List[Union[int, float]]], grade_modifiers: Iterable[Callable[int, int]]) -&amp;gt; Dict[str, float]: ... Lets analyse each kwarg to explain the documentation provided by the typing annotation: student_info: Tuple[str, str, Mapping[str, int]] The student_info kwarg expects a tuple with three elements, a string, a string and dict-like object that maps strings to ints. Lets take a deeper look. Tuple describes that the type should be a tuple that containts on each position instances of the subscripted types. Here he observe that the kwarg student expects a tuple with three elements, a string, a string and a Mapping generic type that we will talk through soon. The Tuple generic is actually a gem, due to the actual immutability of tuples. Mapping generic is the right way of describing key-value data structures like: dict, ChainMap, TypedValue or any custom key-value data structure, this one describers a mapping from str objects to int objects. grades: Optional[List[Union[int, float]]] The grades expects either None or a list that contains either ints or floats. Optional describes that the type can be the subscripted type or None. By using the Optional generic on the grades kwarg we mark the optional existence of an actual list. The Optional[Type] is equivalent with Union[Type, None]. One might say that it should be Union[Type, NoneType], but as PEP 484 states, None and NoneType are equivalent when type hinting. On a personal note, I don’t like this. List describes that the type should be a list that contains elements that are instaces of the subscripted type. In the above example, we observe that the list grades, if it exists due to the Optional generic, should contain a Union type only, which we will cover next. We will see why we favor the usage of Iterable instead of List. Union describes that the elements of the optional list of the kwarg grades can be either str or int. Union types represent a common artificial parent of the subscripted types that can be used to represent all of them to a static typechecking tool. As a side note, there is no interpreter speedup on using Union types, as Python remains a dynamic language, compared to usage of union types in static languages like C. grade_modifiers: Iterable[Callable[int, int]]): The grade_modifiers kwarg expects a list-like structure that contains function-like objects that expect an int parameter and returns an int object. Iterable generics are the way to describe an iterable type like: set, list, or any custom made type that is iterable, making in generic and permissive. The items generated by the iterator must be an instance of the subscripted type of the generic. In the above example, the kwarg grade_modifiers is an iterable object. Callable generic is an abstraction over any object that can be called on which we can enforce further typing, for example, my_func = lambda x: x + 1 has no possibility of further type hinting, but my_func: Callable[int, int] = lambda x: x + 1 gives the reader a type hint on the further usage of the lambda function. Any callable object (functions, methods, lambda function, callable objects) are an instance of the Callable generic. Dict[str, float] Dict describes that the return type of our function should be a dict with the keys of type str and value of type float. This is not overall not recommended to use due to the lack of genericity, the corect way to represent such data structures is to use Mapping, as this coveres generic key-value structures, one of the most interesting such objects being TypedDict. ForwardRef and future annotations One of the common downfalls when using explicit type hinting is that it requires to actually have the type available when annotating. This generates boilerplate code that is not useful and can generate the infamous circular dependecy error. from module.db1 import db1 from module.db2 import db2 from module.db3 import db3 def func(name: str, grades: list, database: Union[db1, db2]) -&amp;gt; None: ... As of python3.8, if you are using the annotations from the __future__ package, types can be stored as qualified string paths and will be resolved at runtime/when the typechecking tools needs it. This actually provided an amazing speedup in the typing package. from __future__ import annotations import module from typing import Union def func(name: str, grades: list, database: Union[&quot;module.db1&quot;, &quot;module.db2&quot;]) -&amp;gt; None: ... print (func.__annotations__) # {'name': &amp;lt;class 'str'&amp;gt;, 'grades': &amp;lt;class 'list'&amp;gt;, 'database': typing.Union['module.database1', 'module.database2']} If you are not using the annotations package, the interpreter creates ForwardRef objects, as types are not stored as strings. import module from typing import Union def func(name: str, grades: list, database: Union[&quot;module.db1&quot;, &quot;module.db2&quot;]) -&amp;gt; None: ... print (func.__annotations__) # {'name': &amp;lt;class 'str'&amp;gt;, 'grades': &amp;lt;class 'list'&amp;gt;, 'database': typing.Union[ForwardRef('module.database1'), ForwardRef('module.database2')]} Final and @final The Final type and the @final decorator are useful when: a class shouldn’t be inherited. a method shouldn’t be overriden. a variable shouldn’t be reassigned. from typing import Final, final class Interface: # don't reassign me PI: Final = 3.14 #don't override me @final def pi(self): return Interface.PI def compute(self) raise NotImplemented # don't inherit me anymore @final class Implementation(Interface): def compute(self): raise 2*self.pi() Breaking these constraints will result in raising an error. One interesting fact is the the Final is actually a generic one, being able to be subscripted. Why would this be useful? To keep a reference to a container object, like: from typing import Final, Dict grades_dict: Final[Dict[str, int]] = dict() In this post, we’ve observed how to improve a python codebase by providing better documentation and type hinting, enabling static type checking for IDEs. In further posts we will talk about building restrictions based on annotations.</summary>
      

      
      
    </entry>
  
  
</feed>
